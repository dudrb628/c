#include <turboc.h>

void main()
{
	// clrscr() : Clear Screen 화면을 깔끔하게 지우고 커서를 화면 좌상단으로 옮긴다.

	/*
		gotoxy(x,y)
			콘솔 화면은 일반적으로 가로로 80개의 문자를 표시할 수 있고 세로로 25줄을 출력할 수 있다.
			윈도우즈의 콘솔은 설정하기에 따라 더 넓은 폭을 가질 수도 있고 스크롤도 가능하다.
			콘솔은 80*25의 바둑판 같은 좌표 공간이라고 할 수 있는데 각 위치는 x축과 y축의 좌표값을 가진다.
			좌상단의 원점 좌표가 (0, 0)이 되며 우하단의 좌표는 (79, 24)가 되고 중앙의 좌표는 (40, 12) 정도가 될 것이다.

			콘솔 화면으로의 모든 출력은 항상 커서가 있는 현재 위치를 참조하도록 되어 있으며 printf로 문자열을 출력하면 현재 위치에 문자열이 출력된다.
			모든 출력문들은 현재 커서 위치에 문자열을 출력하며 출력한 후 커서를 다음 위치로 옮겨 주는데 커서는 왼쪽에서 오른쪽으로, 위에서 아래로 마치 타자기에 글씨를 써 내려가는 것처럼 움직인다.
			그래서 printf를 계속 호출하면 연속적으로 문자열이 출력된다.

			gotoxy 함수는 커서의 위치, 다음 문자열이 출력될 좌표값을 바꾼다.
	*/
	
	clrscr();
	gotoxy(37, 12);
	printf("center\n");

	/*
		wherex(), wherey()
			gotoxy가 화면의 현재 위치를 바꾸는데 비해 이 두 함수는 화면의 현재 위치를 조사한다.
			whrex는 현재 x좌표를 조사하고 wherey는 현재 y좌표를 조사한다.
			만약 현재 위치에서 오른쪽으로 2칸 더, 아래쪽으로 3칸 더 상댖거인 좌표로 이동하고 싶다면 다음과 같이 호출한다.
	*/
	gotoxy(wherex() + 2, wherey() + 3);

	/*
		puts(문자열)
			puts 함수는 문자열만 출력할 때 사용한다.
			puts는 서식을 다루지 않기 때문에 printf보다 간편하며 속도도 빠르다.
			puts는 문자열을 출력한 후 항상 개행을 하므로 \n을 붙이지 않아도 된다.
	*/
	puts("where");

	/*
		gets(변수) → fgets(변수, 사이즈, 파일(입력방식))
			gets 함수는 문자열을 입력받아 인수로 주어진 변수에 저장하는데 gets(str)은 scanf("%s", str)과 유사하다.
			그러나 scanf는 문자열을 공백에서 끊어 버리기 때문에 긴 문자열을 입력받을 수 없는데 비해 gets는 개행 코드 이전의 모든 문자를 입력받는다는 점이 다르다.
			scanf와 gets의 차이점을 비교해보자
	*/
	char addr[128];
	printf("주소를 입력하세요 : ");
	scanf_s("%s", addr, 128);
	printf("입력 받은 주소 = %s\n", addr);



	// 위 소스 버퍼 제거용(다음 입력 받으려면 필요)
	while (getchar() != '\n');	

	/*
		scanf는 공백 전까지만 입력받고 공백 이후는 입력으로 인정하지 않는다.
		이에 비해 gets(addr)로 입력을 받으면 Enter를 칠 때까지 입력된 모든 문자를 addr에 저장한다.
		즉, scanf의 %s 서식은 단어를 입력받고 gets는 문장을 입력받는다.
	*/
	char addr0[256];
	//("주소를 다시 입력하세요~ : ");
	printf("주소를 다시 입력하세요 : ");
	fgets(addr0, 256, stdin);
	//puts("입력 받은 주소 : \s", addr0)
	printf("입력 받은 주소 : %s\n", addr0);

	
	/*
		putch(c) → _putch(c)
		문자 하나만 출력하는 함수이다.
	*/
	_putch('z');


	/*
		getch() → _getch()
			문자 하나만 입력받는다.
			scanf는 값을 입력한 후 반드시 Enter를 눌러야 하는데 비해 getch는 키를 누르는 즉시(원터치) 눌러진 문자를 조사하므로 Enter키를 누르지 않아도 된다는 것이 장점이다.
			scanf는 입력한 후 Enter키를 누르기 전에 편집을 할 수 있지만 getch는 누르는 즉시 입력되어 버리므로 일단 키보드를 두드리면 입력을 취소할 수 없다.
	*/
	printf("게임을 계속 하시겠습니까? (Y/N) \n");
	int ch = _getch();
	printf("입력값 :%c\n", ch);
	/*
			게임을 계속할 것인지, 아니면 그만둘 것인지를 물어보는데 사용자는 이 질문에 대해 Y나 N키를 눌러 응답해야 한다.
			scanf 함수를 사용한다면 Y 또는 N을 입력한 후 Enter를 눌러야 하므로 번거롭지만 getch를 사용하면 두 키 중 하나가 눌러지는 즉시 키를 입력받으므로 훨씬 더 간단하고 편리하다.
			getch는 사용자가 누른 키의 문자 코드값을 돌려주는데 이 값을 정수형 변수에 대입한 후 사용하면 된다.
			단, 커서 이동키나 펑션키같이 문자가 아닌 키를 누를 경우 getch 함수는 확장키라는 의미의 0xE0 또는 0을 돌려준다.
			이럴 때는 getch 함수를 한 번 더 호출하여 확장키의 키코드를 조사할 수 있다.

			getch는 사용자가 키를 누를 때까지 대기하는 특성이 있다.
			그래서 화면에 출력된 내용을 확인할 시간을 주고자 할 때도 이 함수가 종종 사용된다.
	*/
	puts("=============================================\n");
	puts("아주 복잡한 도표를 출력했다 치자.\n");
	puts("=============================================\n");

	puts("다 보셨으면 아무 키나 누르세요.");
	_getch();	// 이 함수는 결과 확인을 위한 대기용으로도 실용성이 있는데 이때는 눌러진 키를 알고자 하는 것이 아니므로 돌려지는 값을 변수에 대입할 필요는 없다.
	clrscr();
	puts("잘 보셨어요?");

	/*
		getchar(), putchar()
		두 함수 그룹은 버퍼를 사용하는가 아닌가, CR/LF 변환을 하는가 아닌가, 문자의 속성 표현 유무, 에러 처리 방식, 입력 완료 시점 등의 많은 차이점이 존재하는데 보통의 경우에는 getch, putch와 별 차이가 없으므로 같은 함수라고 생각해도 무방하다.
		getchar는 엔터를 눌러야만 문자를 입력받으므로 게임 제작, 메뉴 입력 등의 실습에 어울리지 않는다.
	*/



	/*
		delay(n)
			인수로 주어진 n만큼 시간을 지연시키는데 1/1000초 단위로 아무 것도 하지 않고 대기한다.
			delay(100)을 호출하면 0.1초간 대기하며 delay(1000)을 호출하면 1초간 대기한다.
	*/
	printf("2초 후에 화면을 지웁니다.\n");
	delay(2000);
	clrscr();
	printf("깨끗하지요?\n");


	/*
		exit(0)
			프로그램을 강제로 종료한다.
			exit의 괄호 안에는 프로그램 자체의 리턴값을 적는데 정상적으로 종료했을 때 0을 넘기며 실행 중 에러가 발생했을 때 0이 아닌 에러 코드(주로 -1)를 넘기도록 약속되어 있다.
			프로그램의 리턴값은 프로그램을 실행시킨 쉘로 전달되는데 이 값은 잘 사용되지 않으므로 통상 exit(0) 형식대로 사용하면 된다.
	*/
	puts("\n\n1초뒤 프로그램을 종료합니다.\n");
	delay(1000);
	//exit(0);


	/*
		kbhit() → _kbhit()
			키보드의 키가 눌러져 있는지 조사한다.
			눌러졌으면 참의 값을 리턴하고 그렇지 않을 경우에는 거짓의 값을 리턴한다.
			보통 if 조건문과 함께 사용되며 키가 눌러져 있을 때만 getch 함수를 호출하여 눌러진 키를 조샇나다.
	*/
	puts("키 하나 눌러보세요");
	delay(1500);
	if (_kbhit()) ch = _getch();
	printf("%c\n", ch);


	/*
		setcursortype(커서형태)
			커서의 형태를 변경한다.
			괄호안의 인수로 NOCURSOR를 전달하면 커서가 사라지고 NORMALCURSOR라고 주면 커서가 다시 나타난다.
			SOLIDCURSOR로 지정하면 커서가 문자 높이만큼의 크기를 가진다.
			커서는 잠시 숨겨지는 것이지 커서 자체가 없어지는 것은 아니다.
			통상적인 경우 커서는 꼭 필요하지만 게임 같은 경우에는 커서가 오히려 방해가 되므로 표시하지 않는 것이 더 좋다.
	*/
	setcursortype(SOLIDCURSOR);
	delay(2000);
	exit(0);
}