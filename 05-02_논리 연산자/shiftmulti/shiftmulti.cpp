// 비트를 이동시키는 쉬프트 연산은 곱셈과 나눗셈의 대용으로 사용할 수 있다.
#include <turboc.h>

void main()
{
	int i;

	printf("정수를 입력하세요 : ");
	scanf_s("%d", &i);
	printf("결과=%d\n", i << 1);		// 왼쪽으로 한 칸
}


/*
	입력한 수의 정확하게 2배되는 값이 출력된다.
	정수를 왼쪽으로 한 칸 쉬프트하면 두 배가 되며 오른쪽으로 한 칸 쉬프트하면 절반이 된다.
	이진수의 각 자리수는 2의 거듭승에 해당하는 값을 표현한다.
	그런데 비트를 왼쪽으로 한 칸 이동시키면 모든 자리수의 지수가 1 올라가기 때문에 2배가 된다.
	단, 용량 한계를 넘어서는 값은 잘려 나가는데 이는 어쩔 수 없다.
	예를 들어 16비트 정수 40000을 왼쪽으로 쉬프트하면 80000이 되는데 16비트로는 이 값을 표현할 수 없으므로 제일 오른쪽의 1이 밀려나고 결과는 14464가 된다.
		이 값은 80000-65536인데 밀려나서 버려진 오른쪽 비트의 값이 65536이기 때문이다.

	왼쪽으로 쉬프트하는 연산이 값을 두 배로 만드는데 비해 오른쪽으로 쉬프트하는 연산은 값을 절반으로 만든다.
	모든 자리수의 지수가 1 감소하기 때문이다.
	오른쪽 쉬프트는 자리 넘침이 발생하지 않지만 오른쪽으로 밀려나 사라지는 값만큼 오차가 생길 수는 있다.
	짝수를 밀면 정확하게 절반이 되지만 홀수를 밀면 제일 오른쪽에 있던 1이 밀려 나므로 실제값보다 0.5 더 작은 값이 계산된다.
	예를 들어 이진수 0111(7)을 오른쪽으로 밀면 b0가 밀려나고 0011(3)이 된다.
	정확하게 계산하자면 3.5가 되어야 맞지만 비트는 정수의 세계이기 때문에 밀려난 0.5는 사라지게 된다.

	쉬프트 연산과 곱셈 연산의 관계를 일반화해보면
	a << b == a*2의b승
	이다.
	이 공식은 b가 음수일 때도 똑같이 적용된다.
	a를 -1만큼 왼쪽으로(즉 오른쪽으로 한 칸) 밀면 2로 나누는(2의 -1승을 곱하는) 것과 같다.
	그래서 곱셈 댓니에 쉬프트 연산을 사용할 수 있는데 이 두 연산은 엄청난 속도 차이가 있다.
	비트를 이동시키는 것과 일정 횟수 더하기를 반복하는 것은 CPU 입장에서 보면 완전히 다른 작업이기 때문에 속도차가 무려 10배 정도 난다.
	쉬프트 연산은 전혀 논리적이지 않으며 기계적이므로 기계가 하기에는 아주 쉬운 연산인 것이다.
	즉, a*2를 한 번 할 시간이면 a << 1을 10번 정도 할 수 있다는 얘기다.
	이렇게 속도차가 나기 때문에 핵심 게임 엔진이나 시스템 프로그래머들은 곱셈 대신 쉬프트 연산을 즐겨 사용한다.

	쉬프트 연산이 곱셈에 비해 불리한 점은 2의 거듭승에 대해서만 곱셈이 가능하다는 점이다.
	2배, 4배, 8배, 16배 등만 할 수 있으며 3배, 17배 이런 연산은 할 수 없다.
	그러나 쉬프트 연산과 덧셈, 뺄셈을 잘 조합하면 이런 연산이 가능해지기도 한다.
		3배 : a << 1 + a;
		9배 : a << 3 + a;
		15배 : a << 4 - a;
		60배 : a << 6 - a << 2;
*/