/*
*	캐스트 연산자
*		캐스트 연산자는 수식 내에서 변수의 타입을 강제로 다른 타입으로 바꾼다.
*		별다른 지정이 없으면 변수의 고유한 타입대로 연산이 수행되는데 가끔 타입을 바꿔서 연산해야 할 경우가 있다.
*		캐스트 연산자의 형식은 다음 두 가지가 있다.
*			
*			(타입)변수
*			타입(변수)
*		
*		전자는 C언어의 캐스트 연산자 형식이며 후자는 C++언어에서 새로 추가된 캐스트 연산자 형식이다.
*		C++ 컴파일러에서는 두 형식 모두 사용할 수 있는데 C++형식이 함수 호출문과 유사해서 더 명시적이고 가독성이 좋다.
*		하지만 C형식도 기능상 특별한 문제가 없고 오랫동안 사용해 왔기 때문에 아직까지도 C++형식보다는 C형식이 더 많이 사용된다.
*		캐스트 연산자는 어디까지나 수식 내에서 변수의 타입을 임시적으로 바꾸는 것이지 변수의 타입 자체를 바꾸는 것은 아니다.
* 
*		다음 예제는 두 개의 정수를 입력받아 이 수들의 비율을 구해 출력한다.
*/

#include <turboc.h>

void main()
{
	int i, j;
	double r;

	printf("두 개의 정수를 입력하십시오(a b) : ");
	scanf_s("%d %d", &i, &j);
	//r = i / j;
	/*
	*	i와 j에 정수를 입력받은 후 이 두 수의 비율 i/j를 실수형 변수 r에 대입 했다.
	*	만약 i에 4, j에 5를 입력했다면 비율 r은 0.8이 되어야 정상이다.
	*	그러나 실제로 실행해 보면 0으로 계산되는데 왜냐하면 i/j가 정수 나눗셈을 하기 때문이다.
	*	/ 연산자는 피연산자가 모두 정수형이면 나누기를 한 후 소수점 이하를 버리고 몫만 리턴한다.
	*	그래서 0.8이 아닌 0이 계산되는 것이다.
	*	
	*	둘 중 하나가 정수 상수라면 i/3.0식으로 뒤에 소수점을 붙여 실수 상수로 만드는 방식을 쓸 수 있지만 이 경우는 둘 다 변수이기 때문에 i/j.0으로 표기할 수 없다.
	*	이 문제를 해결하려면 i나 j를 실수형으로 바꾼 후 나눗셈을 해야 하는데 캐스트 연산자로 i나 j를 잠시 실수형으로 바꾸면 된다.
	*/
	r = (double)i / j;
	/*
	*	i는 정수형 변수이지만 (double)i는 수식 내에서 임시적으로 실수값으로 평가된다.
	*	그렇다고 해서 i가 실수형 변수가 되는 것은 아니다.
	*	i를 잠시 실수형으로 바꾸어 나눗셈을 하면 / 연산자가 실수 나누기를 하게 되고 비율을 제대로 계산해 낸다.
	*	i/(double)j 라고 해도 되고 둘 다 캐스팅을 해도 상관없다.
	*	어차피 / 연산자가 실수 연산을 하도록 하기만 하면 된다.
	*	그러나 double(i/j)는 이미 정수 나눗셈을 하고 그 결과를 실수로 바꾸기 때문에 원하는 결과가 나오지 않는다.
	*/

	printf("%d와 %d의 비율은 %f입니다.\n", i, j, r);
}
/*
*	int, double, char 등의 기본형은 물론이고 포인터형, 열거형, 배열형 등 모든 타입을 캐스트 연산에 사용할 수 있다.
*	심지어 사용자가 만든 타입까지도 캐스트 연산의 대상이 될 수 있다.
*/